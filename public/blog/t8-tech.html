<!DOCTYPE html>
<html>
    <head>
        <link type="text/css" rel="stylesheet" href="../stylesheets/blog_template_stylesheet.css">
        <title>Adell's Blog</title>
    </head>

<body>
    <div id="container">
        <div id="header">
             Blog
        </div>
        <div id="nav">
            <a href="../index.html">About</a> <a href="../portfolio.html">Portfolio</a> <a href="blog\t1-git-blog.html">Blog</a> <a href="mailto:adell.hk@gmail.com"><img width=44px src="../imgs/gmail-166x120.png"></a><a href="https://github.com/adellhk/"><img height=36px src="../imgs/github-128.png"></a><a href="https://plus.google.com/u/0/100398098310213940030"><img height=36px src="../imgs/google+.png"></a><a href="https://twitter.com/iamadell"><img height=36px src="../imgs/twitter-bird.png"></a><a href="https://www.facebook.com/adell.hk"><img height=36px src="../imgs/facebook.png"></a>
        </div>
        <div id="section">
            <table width="100%" align="center">     
                <tr>
                    <td><a href="c7-values.html">Previous</a></td>
                    <td>1.4.15</td>
                    <td><a href="c8-conflict.html">Next</a></td>
                </tr>
            </table>
            <h1 align="center">Ruby RegEx!!</h1>
            <h3>Regular Expressions</h3>
            <p>From the first time that I saw weird percent signs and slashes in example Ruby blocks, I knew the day would come when I would eventually have to learn RegEx. I'm excited for this opportunity. RegEx, or Regular Expressions, allow you to manipulate strings by matching, extracting, and changing them.</p>
            
            <h3>Matching</h3>
            <p>The first step of using RegEx is to match a pattern to a string. For example, using the <inline-pre>=~</inline-pre> operator, we ask Ruby if a string includes a pattern.</p>
            <pre>"Spearmint, peppermint, everymint. Mint skittles. Refreshing" =~ /mint/ #=> 5</pre>
            <p>The pattern to match against is surrounded by <inline-pre>/</inline-pre>s. Ruby will return the character number (counting from 0) at which the first match occurs. If there is no match, it will return nil.</p>
            <pre>"Mint. Skittles. Yas. In stores such as: none." =~ /Safeway/ #=> nil</pre>
            <p>Also, the string and RegEx can be on either side of the equals-tilde and Ruby will return the same result.</p>
            <pre>/Skittles/ =~ "Mint Skittles 5ever!" #=> 5</pre>
            <p>The <inline-pre>!~</inline-pre> operator checks if a string does not match a pattern. It returns true if the string does not match the pattern, or false if the string does match the pattern.</p>
            <pre>"Break me off a piece of that mint skittle!" !~ /kit kat/ #=> true</pre>
            <pre>"Break me off a piece of that mint skittle!" !~ /skittle/ #=> false</pre>

            <h3>Matching with Scan</h3>
            <p>Scan returns all of the matches for a pattern from a string.</p>
            <pre>"ho home hope".scan(/ho/) #=> ["ho", "ho", "ho"]</pre>
            <p>If we want to match only the "ho" from "home", we can use a specific matching pattern called a lookahead, which looks like <inline-pre>(/ho(?=me)/)</inline-pre>.</p>
            <pre>"ho home hope".scan(/ho(?=me)/) #=> ["ho"]</pre>

            <h3>Replacing with Gsub</h3>
            <p>We can replace a specific portion of a specific word with RegEx. Here, we'll change "home" into "gnome".</p>
            <pre>"ho home hope".gsub(/ho(?=me)/, "gno") #=> "ho gnome hope"</pre>
            <p>We can also replace matches from words that do not match a lookahead. We'll change "ho" and "hope" into "gno" and "gnope", but we won't touch "home".</p>
            <pre>"ho home hope".gsub(/ho(?!me)/, "gno") #=> "gno gnope home"</pre>
            <p>We can use a lookbehind, that is, matching a pattern only if it is preceded by the lookbehind.</p>
            <pre>"gnome home dome".gsub(/(?<=ho)me/, "g") #=> gnome hog dome</pre>
            <p>Similarly, we can use a "not" lookbehind. That is we will only match a pattern if it is not preceded by our lookbehind.</p>
            <pre>"gnome home dome".gsub(/(?<!ho)me/, "g") #=> "gnog home dog"</pre>

            <h3>Match Quantifiers</h3>
            <p>There are three kind of match quantifiers: greedy, lazy, and possessive. A brief eplanation follows in this paragraph, but I don't completely understand them yet. You can read more about them <a href="https://www.bluebox.net/insight/blog-article/using-regular-expressions-in-ruby-part-3-of-3">here</a> if you would like. A greedy quantifier is specified by adding <inline-pre>.+</inline-pre> in a regex between the opening <inline-pre>/</inline-pre> and the pattern, such as <inline-pre>/.+ho/</inline-pre>. A greedy quantifier will try many ways to match a pattern to a string, which could use a lot of resources. A lazy quantifier is specified with <inline-pre>.+?</inline-pre> and will look through the string once from the beginning and only return as much of the string as is required to make a match. Lastly, a possessive quantifier, specified with <inline-pre>.++</inline-pre>, will look through a string once to find a match, and if it doesn't finy it, will fail. They are resource-efficient because they fail quickly.</p>

        </div>
        <div id="footer"><!--Footer--></div>
    </div>
</html>